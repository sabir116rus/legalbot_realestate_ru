
# LegalBot — Юридический Telegram‑бот (Недвижимость, RU)

Проект: чат-бот в Telegram c нейроассистентом OpenAI для консультаций по теме **недвижимости**. 
Подход: **Python (aiogram 3) + простая RAG по CSV**.

## Быстрый старт

1) Создай бота у @BotFather и получи **TELEGRAM_BOT_TOKEN**.  
2) Получи ключ OpenAI и укажи **OPENAI_API_KEY**.  
3) Скопируй `.env.example` в `.env` и заполни значения: обязательно укажи токены OpenAI и Telegram, при необходимости отредактируй `PRIVACY_POLICY_MESSAGE` и `PRIVACY_POLICY_WEBAPP_URL`, а для синхронизации с Google Drive добавь `GOOGLE_DRIVE_*` переменные (папки и файлы).
4) Установи зависимости (включают `aiogram`, `aiohttp`, `rapidfuzz`, `tiktoken`, а также `pytest` и `pytest-asyncio` для тестов):
   ```bash
   pip install -r requirements.txt
   ```
5) Запусти бота:  
   ```bash
   python bot.py
   ```

Команды:
- `/start` — приветствие и запуск
- `/help` — помощь и подсказки по формату вопросов
- `/consultation` — сбор заявки на персональную консультацию
- `/new_ask` — очистка истории, следующий вопрос пойдёт без предыдущего контекста

История переписки хранится в оперативной памяти и используется при генерации ответа (до 10 последних сообщений пользователя и бота). В любой момент можно обнулить контекст командой `/new_ask` — после этого следующий запрос будет обработан как новый диалог.

Вопросы можно задавать в свободной форме: просто отправь текст с описанием ситуации, и бот подберёт ответ из базы знаний.

## Архитектура

```
Telegram (пользователь)
   ↓
Aiogram (бот)
   ↓
OpenAI (GPT)  ←  RAG (CSV: data/knowledge.csv)
   ↓
Форматированный ответ с рекомендациями и ссылками
```

## Структура
```
legalbot_realestate_ru/
├─ bot.py                    # основной скрипт бота
├─ config.py                 # загрузка переменных окружения и путей к ресурсам
├─ rag.py                    # загрузка CSV и поиск релевантных статей/ответов
├─ analyze_logs.py           # утилита для аналитики логов
├─ evaluate_csv_coverage.py  # отчёт по не покрытым вопросам
├─ prompt_system_ru.txt      # системные инструкции ассистента
├─ requirements.txt
├─ .env.example
├─ services/
│  ├─ answer_service.py              # бизнес-логика генерации ответов через OpenAI и RAG
│  ├─ interaction_logger.py          # запись вопросов/ответов в CSV с токенами и статусом
│  ├─ consultation_logger.py         # хранение заявок на консультации в отдельном CSV
│  ├─ contact_validation.py          # проверка и нормализация контактов для заявок
│  ├─ consent_store.py               # асинхронное хранилище согласий пользователей
│  ├─ google_drive_client.py         # клиент для выгрузки файлов и таблиц в Google Drive
│  └─ webapp/
│     ├─ privacy_policy.html         # статическая страница политики конфиденциальности
│     └─ privacy_policy_webapp.py    # минимальное веб-приложение aiohttp для выдачи HTML
├─ data/
│  ├─ knowledge.csv                  # база знаний (CSV)
│  ├─ log.csv                        # лог вопросов/ответов (создаётся автоматически)
│  ├─ consultations.csv              # заявки на консультации (создаётся автоматически)
│  └─ consents.json                  # согласия пользователей на обработку данных
└─ tests/                            # автотесты pytest и pytest-asyncio
```

## Основные компоненты

- `Config.load` из `config.py` читает переменные окружения, подставляет значения по умолчанию, проверяет обязательные ключи и подготавливает пути к базе знаний, системному промпту и CSV‑логу.
- `AnswerService` (см. `services/answer_service.py`) объединяет результаты RAG с системным промптом и вызывает `AsyncOpenAI` для получения ответа. В ответ включаются найденные фрагменты, при сетевых ошибках возвращается человеко‑понятное сообщение и статус `error`.
- `InteractionLogger` (см. `services/interaction_logger.py`) создаёт CSV‑лог, добавляет заголовки при первом запуске, сохраняет обрезанные ответы, top_score и количество токенов (через `tiktoken`) и, при наличии настроек Google Drive, синхронизирует `log.csv` в заданную папку.
- `ConsultationLogger` (см. `services/consultation_logger.py`) сохраняет заявки на живую консультацию в файл `data/consultations.csv` и может автоматически выгружать обновления в Google Drive.
- `ConsentStore` (см. `services/consent_store.py`) поддерживает персистентное хранение согласий пользователей на обработку данных в файле `data/consents.json`. Согласие требуется для всех действий, включая вопросы без команд.
- `validate_contact` (см. `services/contact_validation.py`) нормализует телефоны, email и Telegram‑ники, возвращая очищенное значение либо выбрасывая `ContactValidationError`. Используется в диалоге `/consultation`, чтобы записывать только корректные контакты.
- `GoogleDriveClient` (см. `services/google_drive_client.py`) инкапсулирует загрузку CSV и обновление Google Sheets по сервисному аккаунту, позволяя логам, отчётам и заявкам автоматически синхронизироваться с Drive.

### Структура ответов бота

`AnswerService.generate_answer` возвращает `AnswerResult`, который содержит:

- `text` — финальный ответ без Markdown‑форматирования;
- `top_score` — оценку релевантности лучшего фрагмента из базы знаний;
- `status` — `ok` или `error`, что позволяет анализировать отказы сети и отображается в CSV‑логах.

В `bot.py` добавляется подсказка о `/new_ask`, а также обязательный дисклеймер о том, что ответ носит информационный характер.

### Контекст и новые вопросы

Бот хранит историю сообщений в памяти (до `HISTORY_LIMIT = 10`) и передаёт её вместе с новым вопросом, что улучшает последовательность диалога. Команда `/new_ask` очищает историю именно для текущего пользователя, поэтому следующие сообщения формируются без влияния предыдущих ответов.

## Заявка на консультацию

Команда `/consultation` запускает короткий диалог:
1. Бот спрашивает имя и фамилию пользователя.
2. Затем просит контакты (телефон, email, ник в мессенджере).
3. На последнем шаге пользователь описывает свой запрос.

После получения всех ответов бот подтверждает сохранение заявки и записывает данные в `data/consultations.csv`. Таблица содержит столбцы `timestamp`, `user_id`, `username`, `full_name`, `contact`, `request`. Файл можно открыть в Excel/Google Sheets, передать юристу и использовать для обратной связи с пользователем.

Каждый контакт перед сохранением обрабатывается функцией `validate_contact`, которая приводит телефон к международному формату, проверяет адрес электронной почты или Telegram‑ник и возвращает понятное сообщение об ошибке, если данные нельзя распознать.

## Утилиты

- `analyze_logs.py` — собирает статистику по CSV логам, строит распределения по темам, моделям и временным интервалам. Пример запуска:
  ```bash
  python analyze_logs.py --log data/log.csv
  ```

## Веб-приложение политики конфиденциальности

Если Telegram требует публичную ссылку на политику конфиденциальности, подними мини-веб-приложение из пакета `services.webapp`.
Команда запускает сервер на указанном хосте и порту и отдаёт готовый HTML:

```bash
python -m services.webapp.privacy_policy_webapp --host 0.0.0.0 --port 8080
```

После старта настрой переменную окружения `PRIVACY_POLICY_WEBAPP_URL`, чтобы бот раздавал эту ссылку пользователям, например:

```bash
export PRIVACY_POLICY_WEBAPP_URL="http://localhost:8080/privacy-policy"
```

Замените `localhost` и порт на адрес, доступный вашим пользователям (например, домен сервера или reverse-proxy).

## Интеграция с Google Drive

Бот может автоматически синхронизировать логи, заявки и отчёты с Google Drive. Для этого используется сервисный аккаунт, которому выдаются права на нужные папки и предсозданные таблицы.

**Шаг 1. Создать проект в Google Cloud**

- Откройте: <https://console.cloud.google.com>.
- В шапке слева от «Google Cloud» нажмите на селектор проекта → **New Project / Новый проект**.
- Введите имя (например, `legalbot-drive`) → **Create / Создать**.
- Убедитесь, что выбран именно этот проект (снова проверьте селектор в шапке).

**Шаг 2. Включить Google Drive API**

- Левое меню: **APIs & Services → Enabled APIs & services**.
- Нажмите **+ ENABLE APIS AND SERVICES**.
- В поиске наберите «Google Drive API» → откройте карточку → **Enable**.

**Шаг 3. Включить Google Sheets API**

- В том же каталоге API найдите «Google Sheets API».
- Откройте карточку и нажмите **Enable**, чтобы бот мог обновлять таблицы.

**Шаг 4. Создать сервисный аккаунт и ключ JSON**

- Левое меню: **IAM & Admin → Service Accounts**.
- Нажмите **Create Service Account**.
- Name: `drive-bot` (любое понятное значение) → **Create and Continue**. На шагах ролей можно ничего не добавлять.
- **Done**.
- В списке аккаунтов кликните по созданной записи → вкладка **Keys** → **Add key** → **Create new key**.
- Тип: **JSON** → **Create** → сохранится файл вида `drive-bot-xxxxx.json`.
- Скопируйте e-mail сервисного аккаунта вида `drive-bot@<project-id>.iam.gserviceaccount.com` — он пригодится для расшаривания папок.

**Шаг 5. Поделиться папками на Google Drive с сервисным аккаунтом**

- Откройте <https://drive.google.com>.
- Найдите или создайте три папки (например, `Logs`, `Consultations`, `Reports`).
- Для каждой папки: правая кнопка → **Share / Поделиться** → вставьте e-mail сервисного аккаунта → роль минимум **Editor / Редактор** → **Send / Отправить**.

**Шаг 6. Предсоздать Google Таблицы и получить их ID**

- Внутри каждой папки создайте по Google Таблице: `log` (таблица для логов), `consultations` (таблицадля заявок), `report` (файл/таблица для отчётов).
- Откройте каждую таблицу и скопируйте её ID из адресной строки: часть между `/d/` и `/edit`.
- Эти значения понадобятся для переменных `GOOGLE_DRIVE_LOGS_FILE_ID`, `GOOGLE_DRIVE_CONSULTATIONS_FILE_ID` и `GOOGLE_DRIVE_REPORTS_FILE_ID`.

**Шаг 7. Вытащить ID папок**

- Откройте каждую папку в браузере.
- Скопируйте из URL всё после `folders/` до следующего разделителя — это ID папки.
- Запишите три идентификатора: для `Logs`, `Consultations`, `Reports`.

**Шаг 8. Положить ключ и настроить `.env`**

- Переместите скачанный JSON с ключом в каталог проекта (например, `./secrets/drive-bot.json`). На сервере ограничьте права чтения (например, `chmod 600 secrets/drive-bot.json`).
- Добавьте шаблон в `.gitignore`, чтобы ключ не попал в репозиторий:

  ```
  secrets/*.json
  *.pem
  ```

- Создайте `.env` рядом с `bot.py` и заполните параметры:

  ```env
  GOOGLE_DRIVE_CREDENTIALS_FILE=./secrets/drive-bot.json
  GOOGLE_DRIVE_LOGS_FOLDER_ID=1AbCdEfGhIjKlMn
  GOOGLE_DRIVE_CONSULTATIONS_FOLDER_ID=2ZyXwVuTsRqPoN
  GOOGLE_DRIVE_REPORTS_FOLDER_ID=3QwErTyUiOpAsD
  GOOGLE_DRIVE_LOGS_FILE_ID=1LogSheetIdXXXXXXXXXXXX
  GOOGLE_DRIVE_CONSULTATIONS_FILE_ID=1ConsultSheetIdXXXXXXXX
  GOOGLE_DRIVE_REPORTS_FILE_ID=1ReportSheetOrFileIdXXXXXX
  ```

  Если ключ лежит в корне проекта, путь можно указать как `./drive-bot.json`.

После настройки:

- `InteractionLogger` и `ConsultationLogger` обновляют соответствующие предсозданные Google Таблицы после каждой записи.
- `evaluate_csv_coverage.py` выгружает отчёт и, при использовании `--out`, обновляет экспорт (таблица или файл) в папке `Reports`.
- Все операции с Drive выполняются через `GoogleDriveClient`, который переиспользует одни и те же OAuth‑учётные данные и умеет обновлять как обычные файлы, так и Google Sheets.
- Если переменные не заданы или API недоступен, логирование продолжится локально без ошибок.

## Оценка покрытия

Скрипт `evaluate_csv_coverage.py` помогает определить, какие вопросы в логах остаются без релевантных ответов из базы знаний.

```bash
python evaluate_csv_coverage.py --threshold 60
```

- `--threshold` — минимальное значение `top_score`, при котором вопрос считается покрытым.
- `--recompute-score` — пересчитать оценки через `KnowledgeBase` вместо использования сохранённых `top_score`.
- `--top-n` — сколько самых проблемных вопросов показать в отчёте.
- `--out report.csv` — сохранить таблицу с проблемными вопросами в файл.
- Обе CLI-утилиты завершаются с кодом `1`, если входные данные не найдены или не читаются: `analyze_logs.py` проверяет существование и содержимое лога, а `evaluate_csv_coverage.py` валидирует путь к CSV и корректность параметров.

## CSV — формат базы знаний

| id | topic | question | answer | law_refs | url |
|----|-------|----------|--------|----------|-----|

- **law_refs** — краткие ссылки на статьи/нормы (например: "ГК РФ ст. 209; 454–491; 558").
- **url** — ссылка на первоисточник (Госуслуги, Consultant, Гарант и т. п.).

## Ограничения и дисклеймер

Бот даёт **информационно‑справочные** ответы по открытым источникам и базе знаний. Не является адвокатом.
Для сложных ситуаций рекомендуем очную консультацию юриста.

## Тестирование

Готовые автотесты лежат в каталоге `tests/` и покрывают загрузку конфигурации, работу RAG, генерацию ответов и логи взаимодействий.
После установки зависимостей из `requirements.txt` (включая `pytest` и `pytest-asyncio`) запусти весь набор командой:

```bash
pytest
```

## Развертывание на Scalingo

1. Добавь в репозиторий файлы `Procfile` и `runtime.txt` (уже присутствуют в этой версии проекта). Первый запускает два процесса: HTTP‑сервис с политикой конфиденциальности (`web`) и сам Telegram‑бот (`worker`). Второй фиксирует версию Python `3.10.14`, которую гарантированно поддерживает python-buildpack на Scalingo.
2. Задай переменные окружения в настройках приложения (Dashboard → Environment):
   - `TELEGRAM_BOT_TOKEN`
   - `OPENAI_API_KEY`
   - при необходимости `OPENAI_MODEL`, `RAG_TOP_K`, `PRIVACY_POLICY_MESSAGE` и все `GOOGLE_DRIVE_*`.
   - `PRIVACY_POLICY_WEBAPP_URL` можно не задавать: при развертывании на Scalingo URL сформируется автоматически из `SCALINGO_APP_NAME`.
3. Файлы из каталога `data/` (`knowledge.csv`, `privacy_policy.html` и т. д.) уже находятся в репозитории. Если требуются дополнительные секреты (например, JSON‑ключ сервисного аккаунта Google Drive), добавь их вручную на сервер и укажи путь в переменной `GOOGLE_DRIVE_CREDENTIALS_FILE`.
4. После деплоя включи как минимум один процесс `worker` (бот) и при необходимости один процесс `web` для выдачи политики конфиденциальности. Страница доступна по адресу `https://<app-name>.scalingoapp.com/privacy-policy`.
